{"version":3,"file":"static/js/52.a7d949e1.chunk.js","mappings":"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","sources":["../node_modules/@headlessui/react/src/utils/render.ts","../node_modules/@headlessui/react/src/components/keyboard.ts","../node_modules/@headlessui/react/src/utils/match.ts","../node_modules/@headlessui/react/src/hooks/use-sync-refs.ts","../node_modules/@headlessui/react/src/utils/bugs.ts","../node_modules/@headlessui/react/src/hooks/use-iso-morphic-effect.ts","../node_modules/@headlessui/react/src/hooks/use-server-handoff-complete.ts","../node_modules/@headlessui/react/src/hooks/use-id.ts","../node_modules/@headlessui/react/src/utils/focus-management.ts","../node_modules/@headlessui/react/src/hooks/use-window-event.ts","../node_modules/@headlessui/react/src/internal/open-closed.tsx","../node_modules/@headlessui/react/src/components/popover/popover.tsx","../node_modules/@headlessui/react/src/hooks/use-resolve-button-type.ts"],"sourcesContent":["import {\n  Fragment,\n  cloneElement,\n  createElement,\n  forwardRef,\n  isValidElement,\n\n  // Types\n  ElementType,\n  ReactElement,\n} from 'react'\nimport { Props, XOR, __, Expand } from '../types'\nimport { match } from './match'\n\nexport enum Features {\n  /** No features at all */\n  None = 0,\n\n  /**\n   * When used, this will allow us to use one of the render strategies.\n   *\n   * **The render strategies are:**\n   *    - **Unmount**   _(Will unmount the component.)_\n   *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n   */\n  RenderStrategy = 1,\n\n  /**\n   * When used, this will allow the user of our component to be in control. This can be used when\n   * you want to transition based on some state.\n   */\n  Static = 2,\n}\n\nexport enum RenderStrategy {\n  Unmount,\n  Hidden,\n}\n\ntype PropsForFeature<TPassedInFeatures extends Features, TForFeature extends Features, TProps> = {\n  [P in TPassedInFeatures]: P extends TForFeature ? TProps : __\n}[TPassedInFeatures]\n\nexport type PropsForFeatures<T extends Features> = XOR<\n  PropsForFeature<T, Features.Static, { static?: boolean }>,\n  PropsForFeature<T, Features.RenderStrategy, { unmount?: boolean }>\n>\n\nexport function render<TFeature extends Features, TTag extends ElementType, TSlot>({\n  props,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n}: {\n  props: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>>\n  slot?: TSlot\n  defaultTag: ElementType\n  features?: TFeature\n  visible?: boolean\n  name: string\n}) {\n  // Visible always render\n  if (visible) return _render(props, slot, defaultTag, name)\n\n  let featureFlags = features ?? Features.None\n\n  if (featureFlags & Features.Static) {\n    let { static: isStatic = false, ...rest } = props as PropsForFeatures<Features.Static>\n\n    // When the `static` prop is passed as `true`, then the user is in control, thus we don't care about anything else\n    if (isStatic) return _render(rest, slot, defaultTag, name)\n  }\n\n  if (featureFlags & Features.RenderStrategy) {\n    let { unmount = true, ...rest } = props as PropsForFeatures<Features.RenderStrategy>\n    let strategy = unmount ? RenderStrategy.Unmount : RenderStrategy.Hidden\n\n    return match(strategy, {\n      [RenderStrategy.Unmount]() {\n        return null\n      },\n      [RenderStrategy.Hidden]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: 'none' } } },\n          slot,\n          defaultTag,\n          name\n        )\n      },\n    })\n  }\n\n  // No features enabled, just render\n  return _render(props, slot, defaultTag, name)\n}\n\nfunction _render<TTag extends ElementType, TSlot>(\n  props: Props<TTag, TSlot> & { ref?: unknown },\n  slot: TSlot = {} as TSlot,\n  tag: ElementType,\n  name: string\n) {\n  let { as: Component = tag, children, refName = 'ref', ...passThroughProps } = omit(props, [\n    'unmount',\n    'static',\n  ])\n\n  // This allows us to use `<HeadlessUIComponent as={MyComponent} refName=\"innerRef\" />`\n  let refRelatedProps = props.ref !== undefined ? { [refName]: props.ref } : {}\n\n  let resolvedChildren = (typeof children === 'function' ? children(slot) : children) as\n    | ReactElement\n    | ReactElement[]\n\n  // Allow for className to be a function with the slot as the contents\n  if (passThroughProps.className && typeof passThroughProps.className === 'function') {\n    ;(passThroughProps as any).className = passThroughProps.className(slot)\n  }\n\n  if (Component === Fragment) {\n    if (Object.keys(passThroughProps).length > 0) {\n      if (\n        !isValidElement(resolvedChildren) ||\n        (Array.isArray(resolvedChildren) && resolvedChildren.length > 1)\n      ) {\n        throw new Error(\n          [\n            'Passing props on \"Fragment\"!',\n            '',\n            `The current component <${name} /> is rendering a \"Fragment\".`,\n            `However we need to passthrough the following props:`,\n            Object.keys(passThroughProps)\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n            '',\n            'You can apply a few solutions:',\n            [\n              'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n              'Render a single element as the child so that we can forward the props onto that element.',\n            ]\n              .map(line => `  - ${line}`)\n              .join('\\n'),\n          ].join('\\n')\n        )\n      }\n\n      return cloneElement(\n        resolvedChildren,\n        Object.assign(\n          {},\n          // Filter out undefined values so that they don't override the existing values\n          mergeEventFunctions(compact(omit(passThroughProps, ['ref'])), resolvedChildren.props, [\n            'onClick',\n          ]),\n          refRelatedProps\n        )\n      )\n    }\n  }\n\n  return createElement(\n    Component,\n    Object.assign({}, omit(passThroughProps, ['ref']), Component !== Fragment && refRelatedProps),\n    resolvedChildren\n  )\n}\n\n/**\n * We can use this function for the following useCase:\n *\n * <Menu.Item> <button onClick={console.log} /> </Menu.Item>\n *\n * Our `Menu.Item` will have an internal `onClick`, if you passthrough an `onClick` to the actual\n * `Menu.Item` component we will call it correctly. However, when we have an `onClick` on the actual\n * first child, that one should _also_ be called (but before this implementation, it was just\n * overriding the `onClick`). But it is only when we *render* that we have access to the existing\n * props of this component.\n *\n * It's a bit hacky, and not that clean, but it is something internal and we have tests to rely on\n * so that we can refactor this later (if needed).\n */\nfunction mergeEventFunctions(\n  passThroughProps: Record<string, any>,\n  existingProps: Record<string, any>,\n  functionsToMerge: string[]\n) {\n  let clone = Object.assign({}, passThroughProps)\n  for (let func of functionsToMerge) {\n    if (passThroughProps[func] !== undefined && existingProps[func] !== undefined) {\n      Object.assign(clone, {\n        [func](event: { defaultPrevented: boolean }) {\n          // Props we control\n          if (!event.defaultPrevented) passThroughProps[func](event)\n\n          // Existing props on the component\n          if (!event.defaultPrevented) existingProps[func](event)\n        },\n      })\n    }\n  }\n\n  return clone\n}\n\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport function forwardRefWithAs<T extends { name: string; displayName?: string }>(\n  component: T\n): T & { displayName: string } {\n  return Object.assign(forwardRef((component as unknown) as any) as any, {\n    displayName: component.displayName ?? component.name,\n  })\n}\n\nfunction compact<T extends Record<any, any>>(object: T) {\n  let clone = Object.assign({}, object)\n  for (let key in clone) {\n    if (clone[key] === undefined) delete clone[key]\n  }\n  return clone\n}\n\nfunction omit<T extends Record<any, any>>(object: T, keysToOmit: string[] = []) {\n  let clone = Object.assign({}, object)\n  for (let key of keysToOmit) {\n    if (key in clone) delete clone[key]\n  }\n  return clone\n}\n","// TODO: This must already exist somewhere, right? ðŸ¤”\n// Ref: https://www.w3.org/TR/uievents-key/#named-key-attribute-values\nexport enum Keys {\n  Space = ' ',\n  Enter = 'Enter',\n  Escape = 'Escape',\n  Backspace = 'Backspace',\n\n  ArrowLeft = 'ArrowLeft',\n  ArrowUp = 'ArrowUp',\n  ArrowRight = 'ArrowRight',\n  ArrowDown = 'ArrowDown',\n\n  Home = 'Home',\n  End = 'End',\n\n  PageUp = 'PageUp',\n  PageDown = 'PageDown',\n\n  Tab = 'Tab',\n}\n","export function match<TValue extends string | number = string, TReturnValue = unknown>(\n  value: TValue,\n  lookup: Record<TValue, TReturnValue | ((...args: any[]) => TReturnValue)>,\n  ...args: any[]\n): TReturnValue {\n  if (value in lookup) {\n    let returnValue = lookup[value]\n    return typeof returnValue === 'function' ? returnValue(...args) : returnValue\n  }\n\n  let error = new Error(\n    `Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      lookup\n    )\n      .map(key => `\"${key}\"`)\n      .join(', ')}.`\n  )\n  if (Error.captureStackTrace) Error.captureStackTrace(error, match)\n  throw error\n}\n","import { useRef, useEffect, useCallback } from 'react'\n\nexport function useSyncRefs<TType>(\n  ...refs: (React.MutableRefObject<TType | null> | ((instance: TType) => void) | null)[]\n) {\n  let cache = useRef(refs)\n\n  useEffect(() => {\n    cache.current = refs\n  }, [refs])\n\n  return useCallback(\n    (value: TType) => {\n      for (let ref of cache.current) {\n        if (ref == null) continue\n        if (typeof ref === 'function') ref(value)\n        else ref.current = value\n      }\n    },\n    [cache]\n  )\n}\n","// See: https://github.com/facebook/react/issues/7711\n// See: https://github.com/facebook/react/pull/20612\n// See: https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-disabled (2.)\nexport function isDisabledReactIssue7711(element: Element): boolean {\n  let parent = element.parentElement\n  let legend = null\n\n  while (parent && !(parent instanceof HTMLFieldSetElement)) {\n    if (parent instanceof HTMLLegendElement) legend = parent\n    parent = parent.parentElement\n  }\n\n  let isParentDisabled = parent?.getAttribute('disabled') === '' ?? false\n  if (isParentDisabled && isFirstLegend(legend)) return false\n\n  return isParentDisabled\n}\n\nfunction isFirstLegend(element: HTMLLegendElement | null): boolean {\n  if (!element) return false\n\n  let previous = element.previousElementSibling\n\n  while (previous !== null) {\n    if (previous instanceof HTMLLegendElement) return false\n    previous = previous.previousElementSibling\n  }\n\n  return true\n}\n","import { useLayoutEffect, useEffect } from 'react'\n\nexport const useIsoMorphicEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n","import { useState, useEffect } from 'react'\n\nlet state = { serverHandoffComplete: false }\n\nexport function useServerHandoffComplete() {\n  let [serverHandoffComplete, setServerHandoffComplete] = useState(state.serverHandoffComplete)\n\n  useEffect(() => {\n    if (serverHandoffComplete === true) return\n\n    setServerHandoffComplete(true)\n  }, [serverHandoffComplete])\n\n  useEffect(() => {\n    if (state.serverHandoffComplete === false) state.serverHandoffComplete = true\n  }, [])\n\n  return serverHandoffComplete\n}\n","import { useState } from 'react'\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\nimport { useServerHandoffComplete } from './use-server-handoff-complete'\n\n// We used a \"simple\" approach first which worked for SSR and rehydration on the client. However we\n// didn't take care of the Suspense case. To fix this we used the approach the @reach-ui/auto-id\n// uses.\n//\n// Credits: https://github.com/reach/reach-ui/blob/develop/packages/auto-id/src/index.tsx\n\nlet id = 0\nfunction generateId() {\n  return ++id\n}\n\nexport function useId() {\n  let ready = useServerHandoffComplete()\n  let [id, setId] = useState(ready ? generateId : null)\n\n  useIsoMorphicEffect(() => {\n    if (id === null) setId(generateId())\n  }, [id])\n\n  return id != null ? '' + id : undefined\n}\n","import { match } from './match'\n\n// Credit:\n//  - https://stackoverflow.com/a/30753870\nlet focusableSelector = [\n  '[contentEditable=true]',\n  '[tabindex]',\n  'a[href]',\n  'area[href]',\n  'button:not([disabled])',\n  'iframe',\n  'input:not([disabled])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n]\n  .map(\n    process.env.NODE_ENV === 'test'\n      ? // TODO: Remove this once JSDOM fixes the issue where an element that is\n        // \"hidden\" can be the document.activeElement, because this is not possible\n        // in real browsers.\n        selector => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n      : selector => `${selector}:not([tabindex='-1'])`\n  )\n  .join(',')\n\nexport enum Focus {\n  /** Focus the first non-disabled element */\n  First = 1 << 0,\n\n  /** Focus the previous non-disabled element */\n  Previous = 1 << 1,\n\n  /** Focus the next non-disabled element */\n  Next = 1 << 2,\n\n  /** Focus the last non-disabled element */\n  Last = 1 << 3,\n\n  /** Wrap tab around */\n  WrapAround = 1 << 4,\n\n  /** Prevent scrolling the focusable elements into view */\n  NoScroll = 1 << 5,\n}\n\nexport enum FocusResult {\n  /** Something went wrong while trying to focus. */\n  Error,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n  Overflow,\n\n  /** Focus was successful. */\n  Success,\n\n  /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n  Underflow,\n}\n\nenum Direction {\n  Previous = -1,\n  Next = 1,\n}\n\nexport function getFocusableElements(container: HTMLElement | null = document.body) {\n  if (container == null) return []\n  return Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n}\n\nexport enum FocusableMode {\n  /** The element itself must be focusable. */\n  Strict,\n\n  /** The element should be inside of a focusable element. */\n  Loose,\n}\n\nexport function isFocusableElement(\n  element: HTMLElement,\n  mode: FocusableMode = FocusableMode.Strict\n) {\n  if (element === document.body) return false\n\n  return match(mode, {\n    [FocusableMode.Strict]() {\n      return element.matches(focusableSelector)\n    },\n    [FocusableMode.Loose]() {\n      let next: HTMLElement | null = element\n\n      while (next !== null) {\n        if (next.matches(focusableSelector)) return true\n        next = next.parentElement\n      }\n\n      return false\n    },\n  })\n}\n\nexport function focusElement(element: HTMLElement | null) {\n  element?.focus({ preventScroll: true })\n}\n\nexport function focusIn(container: HTMLElement | HTMLElement[], focus: Focus) {\n  let elements = Array.isArray(container) ? container : getFocusableElements(container)\n  let active = document.activeElement as HTMLElement\n\n  let direction = (() => {\n    if (focus & (Focus.First | Focus.Next)) return Direction.Next\n    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let startIndex = (() => {\n    if (focus & Focus.First) return 0\n    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1\n    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1\n    if (focus & Focus.Last) return elements.length - 1\n\n    throw new Error('Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last')\n  })()\n\n  let focusOptions = focus & Focus.NoScroll ? { preventScroll: true } : {}\n\n  let offset = 0\n  let total = elements.length\n  let next = undefined\n  do {\n    // Guard against infinite loops\n    if (offset >= total || offset + total <= 0) return FocusResult.Error\n\n    let nextIdx = startIndex + offset\n\n    if (focus & Focus.WrapAround) {\n      nextIdx = (nextIdx + total) % total\n    } else {\n      if (nextIdx < 0) return FocusResult.Underflow\n      if (nextIdx >= total) return FocusResult.Overflow\n    }\n\n    next = elements[nextIdx]\n\n    // Try the focus the next element, might not work if it is \"hidden\" to the user.\n    next?.focus(focusOptions)\n\n    // Try the next one in line\n    offset += direction\n  } while (next !== document.activeElement)\n\n  // This is a little weird, but let me try and explain: There are a few scenario's\n  // in chrome for example where a focused `<a>` tag does not get the default focus\n  // styles and sometimes they do. This highly depends on whether you started by\n  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`\n  // then the active element (document.activeElement) is this anchor, which is expected.\n  // However in that case the default focus styles are not applied *unless* you\n  // also add this tabindex.\n  if (!next.hasAttribute('tabindex')) next.setAttribute('tabindex', '0')\n\n  return FocusResult.Success\n}\n","import { useEffect, useRef } from 'react'\n\nexport function useWindowEvent<TType extends keyof WindowEventMap>(\n  type: TType,\n  listener: (this: Window, ev: WindowEventMap[TType]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  let listenerRef = useRef(listener)\n  listenerRef.current = listener\n\n  useEffect(() => {\n    function handler(event: WindowEventMap[TType]) {\n      listenerRef.current.call(window, event)\n    }\n\n    window.addEventListener(type, handler, options)\n    return () => window.removeEventListener(type, handler, options)\n  }, [type, options])\n}\n","import React, {\n  createContext,\n  useContext,\n\n  // Types\n  ReactNode,\n  ReactElement,\n} from 'react'\n\nlet Context = createContext<State | null>(null)\nContext.displayName = 'OpenClosedContext'\n\nexport enum State {\n  Open,\n  Closed,\n}\n\nexport function useOpenClosed() {\n  return useContext(Context)\n}\n\ninterface Props {\n  value: State\n  children: ReactNode\n}\n\nexport function OpenClosedProvider({ value, children }: Props): ReactElement {\n  return <Context.Provider value={value}>{children}</Context.Provider>\n}\n","import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n\n  // Types\n  ContextType,\n  Dispatch,\n  ElementType,\n  KeyboardEvent as ReactKeyboardEvent,\n  MouseEvent as ReactMouseEvent,\n  Ref,\n  MutableRefObject,\n} from 'react'\n\nimport { Props } from '../../types'\nimport { match } from '../../utils/match'\nimport { forwardRefWithAs, render, Features, PropsForFeatures } from '../../utils/render'\nimport { useSyncRefs } from '../../hooks/use-sync-refs'\nimport { useId } from '../../hooks/use-id'\nimport { Keys } from '../keyboard'\nimport { isDisabledReactIssue7711 } from '../../utils/bugs'\nimport {\n  getFocusableElements,\n  Focus,\n  focusIn,\n  FocusResult,\n  isFocusableElement,\n  FocusableMode,\n} from '../../utils/focus-management'\nimport { useWindowEvent } from '../../hooks/use-window-event'\nimport { OpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed'\nimport { useResolveButtonType } from '../../hooks/use-resolve-button-type'\n\nenum PopoverStates {\n  Open,\n  Closed,\n}\n\ninterface StateDefinition {\n  popoverState: PopoverStates\n\n  button: HTMLElement | null\n  buttonId: string\n  panel: HTMLElement | null\n  panelId: string\n}\n\nenum ActionTypes {\n  TogglePopover,\n  ClosePopover,\n\n  SetButton,\n  SetButtonId,\n  SetPanel,\n  SetPanelId,\n}\n\ntype Actions =\n  | { type: ActionTypes.TogglePopover }\n  | { type: ActionTypes.ClosePopover }\n  | { type: ActionTypes.SetButton; button: HTMLElement | null }\n  | { type: ActionTypes.SetButtonId; buttonId: string }\n  | { type: ActionTypes.SetPanel; panel: HTMLElement | null }\n  | { type: ActionTypes.SetPanelId; panelId: string }\n\nlet reducers: {\n  [P in ActionTypes]: (\n    state: StateDefinition,\n    action: Extract<Actions, { type: P }>\n  ) => StateDefinition\n} = {\n  [ActionTypes.TogglePopover]: state => ({\n    ...state,\n    popoverState: match(state.popoverState, {\n      [PopoverStates.Open]: PopoverStates.Closed,\n      [PopoverStates.Closed]: PopoverStates.Open,\n    }),\n  }),\n  [ActionTypes.ClosePopover](state) {\n    if (state.popoverState === PopoverStates.Closed) return state\n    return { ...state, popoverState: PopoverStates.Closed }\n  },\n  [ActionTypes.SetButton](state, action) {\n    if (state.button === action.button) return state\n    return { ...state, button: action.button }\n  },\n  [ActionTypes.SetButtonId](state, action) {\n    if (state.buttonId === action.buttonId) return state\n    return { ...state, buttonId: action.buttonId }\n  },\n  [ActionTypes.SetPanel](state, action) {\n    if (state.panel === action.panel) return state\n    return { ...state, panel: action.panel }\n  },\n  [ActionTypes.SetPanelId](state, action) {\n    if (state.panelId === action.panelId) return state\n    return { ...state, panelId: action.panelId }\n  },\n}\n\nlet PopoverContext = createContext<[StateDefinition, Dispatch<Actions>] | null>(null)\nPopoverContext.displayName = 'PopoverContext'\n\nfunction usePopoverContext(component: string) {\n  let context = useContext(PopoverContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Popover.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, usePopoverContext)\n    throw err\n  }\n  return context\n}\n\nlet PopoverAPIContext = createContext<{\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n} | null>(null)\nPopoverAPIContext.displayName = 'PopoverAPIContext'\n\nfunction usePopoverAPIContext(component: string) {\n  let context = useContext(PopoverAPIContext)\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <${Popover.name} /> component.`)\n    if (Error.captureStackTrace) Error.captureStackTrace(err, usePopoverAPIContext)\n    throw err\n  }\n  return context\n}\n\nlet PopoverGroupContext = createContext<{\n  registerPopover(registerbag: PopoverRegisterBag): void\n  unregisterPopover(registerbag: PopoverRegisterBag): void\n  isFocusWithinPopoverGroup(): boolean\n  closeOthers(buttonId: string): void\n} | null>(null)\nPopoverGroupContext.displayName = 'PopoverGroupContext'\n\nfunction usePopoverGroupContext() {\n  return useContext(PopoverGroupContext)\n}\n\nlet PopoverPanelContext = createContext<string | null>(null)\nPopoverPanelContext.displayName = 'PopoverPanelContext'\n\nfunction usePopoverPanelContext() {\n  return useContext(PopoverPanelContext)\n}\n\ninterface PopoverRegisterBag {\n  buttonId: string\n  panelId: string\n  close(): void\n}\nfunction stateReducer(state: StateDefinition, action: Actions) {\n  return match(action.type, reducers, state, action)\n}\n\n// ---\n\nlet DEFAULT_POPOVER_TAG = 'div' as const\ninterface PopoverRenderPropArg {\n  open: boolean\n  close(focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>): void\n}\n\nexport function Popover<TTag extends ElementType = typeof DEFAULT_POPOVER_TAG>(\n  props: Props<TTag, PopoverRenderPropArg>\n) {\n  let buttonId = `headlessui-popover-button-${useId()}`\n  let panelId = `headlessui-popover-panel-${useId()}`\n\n  let reducerBag = useReducer(stateReducer, {\n    popoverState: PopoverStates.Closed,\n    button: null,\n    buttonId,\n    panel: null,\n    panelId,\n  } as StateDefinition)\n  let [{ popoverState, button, panel }, dispatch] = reducerBag\n\n  useEffect(() => dispatch({ type: ActionTypes.SetButtonId, buttonId }), [buttonId, dispatch])\n  useEffect(() => dispatch({ type: ActionTypes.SetPanelId, panelId }), [panelId, dispatch])\n\n  let registerBag = useMemo(\n    () => ({ buttonId, panelId, close: () => dispatch({ type: ActionTypes.ClosePopover }) }),\n    [buttonId, panelId, dispatch]\n  )\n\n  let groupContext = usePopoverGroupContext()\n  let registerPopover = groupContext?.registerPopover\n  let isFocusWithinPopoverGroup = useCallback(() => {\n    return (\n      groupContext?.isFocusWithinPopoverGroup() ??\n      (button?.contains(document.activeElement) || panel?.contains(document.activeElement))\n    )\n  }, [groupContext, button, panel])\n\n  useEffect(() => registerPopover?.(registerBag), [registerPopover, registerBag])\n\n  // Handle focus out\n  useWindowEvent(\n    'focus',\n    () => {\n      if (popoverState !== PopoverStates.Open) return\n      if (isFocusWithinPopoverGroup()) return\n      if (!button) return\n      if (!panel) return\n\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    true\n  )\n\n  // Handle outside click\n  useWindowEvent('mousedown', event => {\n    let target = event.target as HTMLElement\n\n    if (popoverState !== PopoverStates.Open) return\n\n    if (button?.contains(target)) return\n    if (panel?.contains(target)) return\n\n    dispatch({ type: ActionTypes.ClosePopover })\n\n    if (!isFocusableElement(target, FocusableMode.Loose)) {\n      event.preventDefault()\n      button?.focus()\n    }\n  })\n\n  let close = useCallback(\n    (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => {\n      dispatch({ type: ActionTypes.ClosePopover })\n\n      let restoreElement = (() => {\n        if (!focusableElement) return button\n        if (focusableElement instanceof HTMLElement) return focusableElement\n        if (focusableElement.current instanceof HTMLElement) return focusableElement.current\n\n        return button\n      })()\n\n      restoreElement?.focus()\n    },\n    [dispatch, button]\n  )\n\n  let api = useMemo<ContextType<typeof PopoverAPIContext>>(() => ({ close }), [close])\n\n  let slot = useMemo<PopoverRenderPropArg>(\n    () => ({ open: popoverState === PopoverStates.Open, close }),\n    [popoverState, close]\n  )\n\n  return (\n    <PopoverContext.Provider value={reducerBag}>\n      <PopoverAPIContext.Provider value={api}>\n        <OpenClosedProvider\n          value={match(popoverState, {\n            [PopoverStates.Open]: State.Open,\n            [PopoverStates.Closed]: State.Closed,\n          })}\n        >\n          {render({\n            props,\n            slot,\n            defaultTag: DEFAULT_POPOVER_TAG,\n            name: 'Popover',\n          })}\n        </OpenClosedProvider>\n      </PopoverAPIContext.Provider>\n    </PopoverContext.Provider>\n  )\n}\n\n// ---\n\nlet DEFAULT_BUTTON_TAG = 'button' as const\ninterface ButtonRenderPropArg {\n  open: boolean\n}\ntype ButtonPropsWeControl =\n  | 'id'\n  | 'type'\n  | 'aria-expanded'\n  | 'aria-controls'\n  | 'onKeyDown'\n  | 'onClick'\n\nlet Button = forwardRefWithAs(function Button<TTag extends ElementType = typeof DEFAULT_BUTTON_TAG>(\n  props: Props<TTag, ButtonRenderPropArg, ButtonPropsWeControl>,\n  ref: Ref<HTMLButtonElement>\n) {\n  let [state, dispatch] = usePopoverContext([Popover.name, Button.name].join('.'))\n  let internalButtonRef = useRef<HTMLButtonElement | null>(null)\n\n  let groupContext = usePopoverGroupContext()\n  let closeOthers = groupContext?.closeOthers\n\n  let panelContext = usePopoverPanelContext()\n  let isWithinPanel = panelContext === null ? false : panelContext === state.panelId\n\n  let buttonRef = useSyncRefs(\n    internalButtonRef,\n    ref,\n    isWithinPanel ? null : button => dispatch({ type: ActionTypes.SetButton, button })\n  )\n  let withinPanelButtonRef = useSyncRefs(internalButtonRef, ref)\n\n  // TODO: Revisit when handling Tab/Shift+Tab when using Portal's\n  let activeElementRef = useRef<Element | null>(null)\n  let previousActiveElementRef = useRef<Element | null>(\n    typeof window === 'undefined' ? null : document.activeElement\n  )\n  useWindowEvent(\n    'focus',\n    () => {\n      previousActiveElementRef.current = activeElementRef.current\n      activeElementRef.current = document.activeElement\n    },\n    true\n  )\n\n  let handleKeyDown = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      if (isWithinPanel) {\n        if (state.popoverState === PopoverStates.Closed) return\n        switch (event.key) {\n          case Keys.Space:\n          case Keys.Enter:\n            event.preventDefault() // Prevent triggering a *click* event\n            event.stopPropagation()\n            dispatch({ type: ActionTypes.ClosePopover })\n            state.button?.focus() // Re-focus the original opening Button\n            break\n        }\n      } else {\n        switch (event.key) {\n          case Keys.Space:\n          case Keys.Enter:\n            event.preventDefault() // Prevent triggering a *click* event\n            event.stopPropagation()\n            if (state.popoverState === PopoverStates.Closed) closeOthers?.(state.buttonId)\n            dispatch({ type: ActionTypes.TogglePopover })\n            break\n\n          case Keys.Escape:\n            if (state.popoverState !== PopoverStates.Open) return closeOthers?.(state.buttonId)\n            if (!internalButtonRef.current) return\n            if (!internalButtonRef.current.contains(document.activeElement)) return\n            event.preventDefault()\n            event.stopPropagation()\n            dispatch({ type: ActionTypes.ClosePopover })\n            break\n\n          case Keys.Tab:\n            if (state.popoverState !== PopoverStates.Open) return\n            if (!state.panel) return\n            if (!state.button) return\n\n            // TODO: Revisit when handling Tab/Shift+Tab when using Portal's\n            if (event.shiftKey) {\n              // Check if the last focused element exists, and check that it is not inside button or panel itself\n              if (!previousActiveElementRef.current) return\n              if (state.button?.contains(previousActiveElementRef.current)) return\n              if (state.panel.contains(previousActiveElementRef.current)) return\n\n              // Check if the last focused element is *after* the button in the DOM\n              let focusableElements = getFocusableElements()\n              let previousIdx = focusableElements.indexOf(\n                previousActiveElementRef.current as HTMLElement\n              )\n              let buttonIdx = focusableElements.indexOf(state.button)\n              if (buttonIdx > previousIdx) return\n\n              event.preventDefault()\n              event.stopPropagation()\n\n              focusIn(state.panel, Focus.Last)\n            } else {\n              event.preventDefault()\n              event.stopPropagation()\n\n              focusIn(state.panel, Focus.First)\n            }\n\n            break\n        }\n      }\n    },\n    [\n      dispatch,\n      state.popoverState,\n      state.buttonId,\n      state.button,\n      state.panel,\n      internalButtonRef,\n      closeOthers,\n      isWithinPanel,\n    ]\n  )\n\n  let handleKeyUp = useCallback(\n    (event: ReactKeyboardEvent<HTMLButtonElement>) => {\n      if (isWithinPanel) return\n      if (event.key === Keys.Space) {\n        // Required for firefox, event.preventDefault() in handleKeyDown for\n        // the Space key doesn't cancel the handleKeyUp, which in turn\n        // triggers a *click*.\n        event.preventDefault()\n      }\n      if (state.popoverState !== PopoverStates.Open) return\n      if (!state.panel) return\n      if (!state.button) return\n\n      // TODO: Revisit when handling Tab/Shift+Tab when using Portal's\n      switch (event.key) {\n        case Keys.Tab:\n          // Check if the last focused element exists, and check that it is not inside button or panel itself\n          if (!previousActiveElementRef.current) return\n          if (state.button?.contains(previousActiveElementRef.current)) return\n          if (state.panel.contains(previousActiveElementRef.current)) return\n\n          // Check if the last focused element is *after* the button in the DOM\n          let focusableElements = getFocusableElements()\n          let previousIdx = focusableElements.indexOf(\n            previousActiveElementRef.current as HTMLElement\n          )\n          let buttonIdx = focusableElements.indexOf(state.button)\n          if (buttonIdx > previousIdx) return\n\n          event.preventDefault()\n          event.stopPropagation()\n          focusIn(state.panel, Focus.Last)\n          break\n      }\n    },\n    [state.popoverState, state.panel, state.button, isWithinPanel]\n  )\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return\n      if (props.disabled) return\n      if (isWithinPanel) {\n        dispatch({ type: ActionTypes.ClosePopover })\n        state.button?.focus() // Re-focus the original opening Button\n      } else {\n        if (state.popoverState === PopoverStates.Closed) closeOthers?.(state.buttonId)\n        state.button?.focus()\n        dispatch({ type: ActionTypes.TogglePopover })\n      }\n    },\n    [\n      dispatch,\n      state.button,\n      state.popoverState,\n      state.buttonId,\n      props.disabled,\n      closeOthers,\n      isWithinPanel,\n    ]\n  )\n\n  let slot = useMemo<ButtonRenderPropArg>(\n    () => ({ open: state.popoverState === PopoverStates.Open }),\n    [state]\n  )\n\n  let type = useResolveButtonType(props, internalButtonRef)\n  let passthroughProps = props\n  let propsWeControl = isWithinPanel\n    ? {\n        ref: withinPanelButtonRef,\n        type,\n        onKeyDown: handleKeyDown,\n        onClick: handleClick,\n      }\n    : {\n        ref: buttonRef,\n        id: state.buttonId,\n        type,\n        'aria-expanded': props.disabled ? undefined : state.popoverState === PopoverStates.Open,\n        'aria-controls': state.panel ? state.panelId : undefined,\n        onKeyDown: handleKeyDown,\n        onKeyUp: handleKeyUp,\n        onClick: handleClick,\n      }\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: 'Popover.Button',\n  })\n})\n\n// ---\n\nlet DEFAULT_OVERLAY_TAG = 'div' as const\ninterface OverlayRenderPropArg {\n  open: boolean\n}\ntype OverlayPropsWeControl = 'id' | 'aria-hidden' | 'onClick'\n\nlet OverlayRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Overlay = forwardRefWithAs(function Overlay<\n  TTag extends ElementType = typeof DEFAULT_OVERLAY_TAG\n>(\n  props: Props<TTag, OverlayRenderPropArg, OverlayPropsWeControl> &\n    PropsForFeatures<typeof OverlayRenderFeatures>,\n  ref: Ref<HTMLDivElement>\n) {\n  let [{ popoverState }, dispatch] = usePopoverContext([Popover.name, Overlay.name].join('.'))\n  let overlayRef = useSyncRefs(ref)\n\n  let id = `headlessui-popover-overlay-${useId()}`\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return popoverState === PopoverStates.Open\n  })()\n\n  let handleClick = useCallback(\n    (event: ReactMouseEvent) => {\n      if (isDisabledReactIssue7711(event.currentTarget)) return event.preventDefault()\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    [dispatch]\n  )\n\n  let slot = useMemo<OverlayRenderPropArg>(() => ({ open: popoverState === PopoverStates.Open }), [\n    popoverState,\n  ])\n  let propsWeControl = {\n    ref: overlayRef,\n    id,\n    'aria-hidden': true,\n    onClick: handleClick,\n  }\n  let passthroughProps = props\n\n  return render({\n    props: { ...passthroughProps, ...propsWeControl },\n    slot,\n    defaultTag: DEFAULT_OVERLAY_TAG,\n    features: OverlayRenderFeatures,\n    visible,\n    name: 'Popover.Overlay',\n  })\n})\n\n// ---\n\nlet DEFAULT_PANEL_TAG = 'div' as const\ninterface PanelRenderPropArg {\n  open: boolean\n  close: (focusableElement?: HTMLElement | MutableRefObject<HTMLElement | null>) => void\n}\ntype PanelPropsWeControl = 'id' | 'onKeyDown'\n\nlet PanelRenderFeatures = Features.RenderStrategy | Features.Static\n\nlet Panel = forwardRefWithAs(function Panel<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: Props<TTag, PanelRenderPropArg, PanelPropsWeControl> &\n    PropsForFeatures<typeof PanelRenderFeatures> & {\n      focus?: boolean\n    },\n  ref: Ref<HTMLDivElement>\n) {\n  let { focus = false, ...passthroughProps } = props\n\n  let [state, dispatch] = usePopoverContext([Popover.name, Panel.name].join('.'))\n  let { close } = usePopoverAPIContext([Popover.name, Panel.name].join('.'))\n\n  let internalPanelRef = useRef<HTMLDivElement | null>(null)\n  let panelRef = useSyncRefs(internalPanelRef, ref, panel => {\n    dispatch({ type: ActionTypes.SetPanel, panel })\n  })\n\n  let usesOpenClosedState = useOpenClosed()\n  let visible = (() => {\n    if (usesOpenClosedState !== null) {\n      return usesOpenClosedState === State.Open\n    }\n\n    return state.popoverState === PopoverStates.Open\n  })()\n\n  let handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      switch (event.key) {\n        case Keys.Escape:\n          if (state.popoverState !== PopoverStates.Open) return\n          if (!internalPanelRef.current) return\n          if (!internalPanelRef.current.contains(document.activeElement)) return\n          event.preventDefault()\n          event.stopPropagation()\n          dispatch({ type: ActionTypes.ClosePopover })\n          state.button?.focus()\n          break\n      }\n    },\n    [state, internalPanelRef, dispatch]\n  )\n\n  // Unlink on \"unmount\" myself\n  useEffect(() => () => dispatch({ type: ActionTypes.SetPanel, panel: null }), [dispatch])\n\n  // Unlink on \"unmount\" children\n  useEffect(() => {\n    if (props.static) return\n\n    if (state.popoverState === PopoverStates.Closed && (props.unmount ?? true)) {\n      dispatch({ type: ActionTypes.SetPanel, panel: null })\n    }\n  }, [state.popoverState, props.unmount, props.static, dispatch])\n\n  // Move focus within panel\n  useEffect(() => {\n    if (!focus) return\n    if (state.popoverState !== PopoverStates.Open) return\n    if (!internalPanelRef.current) return\n\n    let activeElement = document.activeElement as HTMLElement\n    if (internalPanelRef.current.contains(activeElement)) return // Already focused within Dialog\n\n    focusIn(internalPanelRef.current, Focus.First)\n  }, [focus, internalPanelRef, state.popoverState])\n\n  // Handle Tab / Shift+Tab focus positioning\n  useWindowEvent('keydown', event => {\n    if (state.popoverState !== PopoverStates.Open) return\n    if (!internalPanelRef.current) return\n    if (event.key !== Keys.Tab) return\n    if (!document.activeElement) return\n    if (!internalPanelRef.current) return\n    if (!internalPanelRef.current.contains(document.activeElement)) return\n\n    // We will take-over the default tab behaviour so that we have a bit\n    // control over what is focused next. It will behave exactly the same,\n    // but it will also \"fix\" some issues based on whether you are using a\n    // Portal or not.\n    event.preventDefault()\n\n    let result = focusIn(internalPanelRef.current, event.shiftKey ? Focus.Previous : Focus.Next)\n\n    if (result === FocusResult.Underflow) {\n      return state.button?.focus()\n    } else if (result === FocusResult.Overflow) {\n      if (!state.button) return\n\n      let elements = getFocusableElements()\n      let buttonIdx = elements.indexOf(state.button)\n\n      let nextElements = elements\n        .splice(buttonIdx + 1) // Elements after button\n        .filter(element => !internalPanelRef.current?.contains(element)) // Ignore items in panel\n\n      // Try to focus the next element, however it could fail if we are in a\n      // Portal that happens to be the very last one in the DOM. In that\n      // case we would Error (because nothing after the button is\n      // focusable). Therefore we will try and focus the very first item in\n      // the document.body.\n      if (focusIn(nextElements, Focus.First) === FocusResult.Error) {\n        focusIn(document.body, Focus.First)\n      }\n    }\n  })\n\n  // Handle focus out when we are in special \"focus\" mode\n  useWindowEvent(\n    'focus',\n    () => {\n      if (!focus) return\n      if (state.popoverState !== PopoverStates.Open) return\n      if (!internalPanelRef.current) return\n\n      if (internalPanelRef.current?.contains(document.activeElement as HTMLElement)) return\n      dispatch({ type: ActionTypes.ClosePopover })\n    },\n    true\n  )\n\n  let slot = useMemo<PanelRenderPropArg>(\n    () => ({ open: state.popoverState === PopoverStates.Open, close }),\n    [state, close]\n  )\n  let propsWeControl = {\n    ref: panelRef,\n    id: state.panelId,\n    onKeyDown: handleKeyDown,\n  }\n\n  return (\n    <PopoverPanelContext.Provider value={state.panelId}>\n      {render({\n        props: { ...passthroughProps, ...propsWeControl },\n        slot,\n        defaultTag: DEFAULT_PANEL_TAG,\n        features: PanelRenderFeatures,\n        visible,\n        name: 'Popover.Panel',\n      })}\n    </PopoverPanelContext.Provider>\n  )\n})\n\n// ---\n\nlet DEFAULT_GROUP_TAG = 'div' as const\ninterface GroupRenderPropArg {}\ntype GroupPropsWeControl = 'id'\n\nfunction Group<TTag extends ElementType = typeof DEFAULT_PANEL_TAG>(\n  props: Props<TTag, GroupRenderPropArg, GroupPropsWeControl>\n) {\n  let groupRef = useRef<HTMLElement | null>(null)\n  let [popovers, setPopovers] = useState<PopoverRegisterBag[]>([])\n\n  let unregisterPopover = useCallback(\n    (registerbag: PopoverRegisterBag) => {\n      setPopovers(existing => {\n        let idx = existing.indexOf(registerbag)\n        if (idx !== -1) {\n          let clone = existing.slice()\n          clone.splice(idx, 1)\n          return clone\n        }\n        return existing\n      })\n    },\n    [setPopovers]\n  )\n\n  let registerPopover = useCallback(\n    (registerbag: PopoverRegisterBag) => {\n      setPopovers(existing => [...existing, registerbag])\n      return () => unregisterPopover(registerbag)\n    },\n    [setPopovers, unregisterPopover]\n  )\n\n  let isFocusWithinPopoverGroup = useCallback(() => {\n    let element = document.activeElement as HTMLElement\n\n    if (groupRef.current?.contains(element)) return true\n\n    // Check if the focus is in one of the button or panel elements. This is important in case you are rendering inside a Portal.\n    return popovers.some(bag => {\n      return (\n        document.getElementById(bag.buttonId)?.contains(element) ||\n        document.getElementById(bag.panelId)?.contains(element)\n      )\n    })\n  }, [groupRef, popovers])\n\n  let closeOthers = useCallback(\n    (buttonId: string) => {\n      for (let popover of popovers) {\n        if (popover.buttonId !== buttonId) popover.close()\n      }\n    },\n    [popovers]\n  )\n\n  let contextBag = useMemo<ContextType<typeof PopoverGroupContext>>(\n    () => ({\n      registerPopover: registerPopover,\n      unregisterPopover: unregisterPopover,\n      isFocusWithinPopoverGroup,\n      closeOthers,\n    }),\n    [registerPopover, unregisterPopover, isFocusWithinPopoverGroup, closeOthers]\n  )\n\n  let slot = useMemo<GroupRenderPropArg>(() => ({}), [])\n  let propsWeControl = { ref: groupRef }\n  let passthroughProps = props\n\n  return (\n    <PopoverGroupContext.Provider value={contextBag}>\n      {render({\n        props: { ...passthroughProps, ...propsWeControl },\n        slot,\n        defaultTag: DEFAULT_GROUP_TAG,\n        name: 'Popover.Group',\n      })}\n    </PopoverGroupContext.Provider>\n  )\n}\n\n// ---\n\nPopover.Button = Button\nPopover.Overlay = Overlay\nPopover.Panel = Panel\nPopover.Group = Group\n","import { useState, MutableRefObject } from 'react'\n\nimport { useIsoMorphicEffect } from './use-iso-morphic-effect'\n\nfunction resolveType<TTag>(props: { type?: string; as?: TTag }) {\n  if (props.type) return props.type\n\n  let tag = props.as ?? 'button'\n  if (typeof tag === 'string' && tag.toLowerCase() === 'button') return 'button'\n\n  return undefined\n}\n\nexport function useResolveButtonType<TTag>(\n  props: { type?: string; as?: TTag },\n  ref: MutableRefObject<HTMLElement | null>\n) {\n  let [type, setType] = useState(() => resolveType(props))\n\n  useIsoMorphicEffect(() => {\n    setType(resolveType(props))\n  }, [props.type, props.as])\n\n  useIsoMorphicEffect(() => {\n    if (type) return\n    if (!ref.current) return\n\n    if (ref.current instanceof HTMLButtonElement && !ref.current.hasAttribute('type')) {\n      setType('button')\n    }\n  }, [type, ref])\n\n  return type\n}\n"],"names":["Features","RenderStrategy","Keys","match","value","lookup","returnValue","args","error","Error","Object","keys","map","key","join","captureStackTrace","render","props","slot","defaultTag","features","visible","name","_render","featureFlags","None","Static","isStatic","rest","unmount","Unmount","Hidden","hidden","style","display","tag","omit","as","Component","children","refName","passThroughProps","refRelatedProps","undefined","ref","resolvedChildren","className","Fragment","length","isValidElement","Array","isArray","line","cloneElement","assign","existingProps","functionsToMerge","clone","func","event","defaultPrevented","mergeEventFunctions","object","compact","createElement","forwardRefWithAs","component","forwardRef","displayName","keysToOmit","useSyncRefs","refs","cache","useRef","useEffect","current","useCallback","isDisabledReactIssue7711","element","parent","parentElement","legend","HTMLFieldSetElement","HTMLLegendElement","isParentDisabled","getAttribute","previous","previousElementSibling","isFirstLegend","useIsoMorphicEffect","window","useLayoutEffect","state","serverHandoffComplete","id","generateId","useId","ready","useState","setServerHandoffComplete","useServerHandoffComplete","setId","Focus","FocusResult","Direction","FocusableMode","focusableSelector","selector","getFocusableElements","container","document","body","from","querySelectorAll","focusIn","focus","elements","active","activeElement","direction","First","Next","Previous","Last","startIndex","Math","max","indexOf","focusOptions","NoScroll","preventScroll","offset","total","next","nextIdx","WrapAround","Underflow","Overflow","hasAttribute","setAttribute","Success","useWindowEvent","type","listener","options","listenerRef","handler","call","addEventListener","removeEventListener","State","PopoverStates","ActionTypes","Context","createContext","useOpenClosed","useContext","OpenClosedProvider","Provider","resolveType","toLowerCase","reducers","TogglePopover","popoverState","Open","Closed","ClosePopover","SetButton","action","button","SetButtonId","buttonId","SetPanel","panel","SetPanelId","panelId","PopoverContext","usePopoverContext","context","err","Popover","PopoverAPIContext","usePopoverAPIContext","PopoverGroupContext","usePopoverGroupContext","PopoverPanelContext","stateReducer","DEFAULT_POPOVER_TAG","reducerBag","useReducer","dispatch","registerBag","useMemo","close","groupContext","registerPopover","isFocusWithinPopoverGroup","contains","target","mode","Strict","matches","Loose","isFocusableElement","preventDefault","focusableElement","restoreElement","HTMLElement","api","open","Button","internalButtonRef","closeOthers","panelContext","isWithinPanel","buttonRef","withinPanelButtonRef","activeElementRef","previousActiveElementRef","handleKeyDown","Space","Enter","stopPropagation","Escape","Tab","shiftKey","focusableElements","previousIdx","handleKeyUp","handleClick","currentTarget","disabled","setType","HTMLButtonElement","useResolveButtonType","onKeyDown","onClick","onKeyUp","OverlayRenderFeatures","Overlay","overlayRef","usesOpenClosedState","PanelRenderFeatures","Panel","passthroughProps","internalPanelRef","panelRef","result","buttonIdx","splice","filter","propsWeControl","Group","groupRef","popovers","setPopovers","unregisterPopover","registerbag","existing","idx","slice","some","bag","getElementById","popover","contextBag"],"sourceRoot":""}